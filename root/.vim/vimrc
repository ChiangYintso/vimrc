set nocp "no Vi-compatible

"""""""""""""""""""""" CONFIG """""""""""""""""""""""""""""""""

if filereadable(expand('~/.vim/config.vim'))
	source ~/.vim/config.vim
endif
" tmux2.2以上才支持true color
let g:vimrc_use_true_color = get(g:, 'vimrc_use_true_color', 0)
let g:vimrc_use_vimspector = get(g:, 'vimrc_use_vimspector', 0)

let g:vim_plug_dir = get(g:, 'vim_plug_dir', '~/plugged')

let g:vimrc_use_coc = get(g:, 'vimrc_use_coc', 1)
let g:coc_data_home = get(g:, 'coc_data_home', '~/coc')
" All Coc Extensions: let g:coc_global_extensions = ['coc-lists', 'coc-ultisnips', 'coc-json', 'coc-vimtex', 'coc-texlab', 'coc-sh', 'coc-rust-analyzer', 'coc-clangd', 'coc-pyright', 'coc-java', 'coc-java-debug', 'coc-go', 'coc-tsserver', 'coc-dictionary', '@yaegassy/coc-marksman', 'coc-explorer']
let g:coc_global_extensions = get(g:, 'coc_global_extensions', [])

" gtags-cscope | cscope
let g:tag_system = get(g:, 'tag_system', 'gtags-cscope')
let g:mapleader = get(g:, 'mapleader', ' ')
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

set noexrc " 不读取当前文件夹的.vimrc
if exists('&viminfofile') && !has('nvim') 
	set viminfofile=$HOME/.vim/.viminfo
	" 保留50个marks
	" 每个寄存器保存50行内容
	" 保存50行搜索历史
	" 保存50行命令历史
	" 禁止hlsearch
	" 禁止保存超过10kb的寄存器内容
	" 保存0-9，A-Zmark
	set viminfo='50,<50,/50,:50,h,s10,f100
endif

set history=500 " Sets how many lines of history VIM has to remember

" Enable filetype plugins
filetype indent on
filetype plugin on

syntax on "语法高亮显示

set encoding=utf-8
set fileencoding=utf-8
" vim自动探测fileencodeing的顺序列表
set fileencodings=utf-8,ucs-bom,gbk,cp936,gb2312,gb18030
set termencoding=utf-8
set fileformats=unix,dos,mac " 文件格式
set number "显示行号
set showmatch  " 输入），}时，光标会暂时的回到相匹配的（，{。如果没有相匹配的就发出错误信息的铃声
set matchtime=1 " showmatch的时间0.1s
set backspace=indent,eol,start "indent: BS可以删除缩进; eol: BS可以删除行末回车; start: BS可以删除原先存在的字符
set hidden " 未保存文本就可以隐藏buffer
set cmdheight=2 " cmd行高2, 减少hit-enter
set wildmenu " command自动补全时显示菜单
set wildmode=list:full " command自动补全时显示整个列表
set wildignore=.git,build
set path=.,, " 当前目录和当前文件所在目录
set updatetime=700 " GitGutter更新和自动保存.swp的延迟时间
set timeoutlen=3000 " key map 超时时间

set autowrite " 自动保存
set cursorline " 高亮当前行

set hlsearch " Highlight search results
set incsearch " 输入搜索内容时就显示搜索结果
set magic "模式匹配时 ^ $ . * ~ [] 具有特殊含义
set lazyredraw " 不要在宏的中间重绘屏幕。使它们更快完成。

set nobackup       "no backup files
set nowritebackup  "only in case you don't want a backup file while editing
set noswapfile     "no swap files

" 会话不保存options, 防止重新set background=dark后，覆盖一些highlight设置
set sessionoptions-=options
""""""""""""""""""""""""""""""
"indent and tab
""""""""""""""""""""""""""""""
set smarttab
set autoindent " 跟随上一行的缩进方式
set smartindent " 以 { 或cinword变量开始的行（if、while...），换行后自动缩进

augroup equalprg_filetype
	autocmd!
	" autocmd FileType c,cpp setlocal equalprg=indent
	" autocmd FileType c,cpp setlocal equalprg=uncrustify\ -c\ .uncrustify.cfg\ --replace\ --no-backup
	autocmd FileType c,cpp setlocal equalprg=clang-format
	autocmd FileType sql setlocal equalprg=sqlformat\ -k\ upper\ -r\ --indent_columns\ %
augroup end

augroup indent2
	autocmd!
	autocmd FileType c,cpp,vim,tex,markdown,html,sh,zsh,json,lua setlocal tabstop=2 shiftwidth=2 softtabstop=2
augroup end
augroup indent4
	autocmd!
	autocmd FileType python,go,rust,java setlocal tabstop=4 shiftwidth=4 softtabstop=4
augroup end

" https://github.com/timakro/vim-yadi/blob/main/plugin/yadi.vim
function s:DetectIndent()
	let tabbed = 0
	let spaced = 0
	let indents = {}
	let lastwidth = 0
	" get the last 300 lines
	let l:first_line = max([0, line('$')-300])
	for line in getline(l:first_line, line('$'))
		if line[0] == "\t"
			let tabbed += 1
		else
			" The position of the first non-space character is the
			" indentation width.
			let width = match(line, "[^ ]")
			if width != -1
				if width > 0
					let spaced += 1
				endif
				let indent = width - lastwidth
				if indent >= 2 " Minimum indentation is 2 spaces
					let indents[indent] = get(indents, indent, 0) + 1
				endif
				let lastwidth = width
			endif
		endif
	endfor

	let total = 0
	let max = 0
	let winner = -1
	for [indent, n] in items(indents)
		let total += n
		if n > max
			let max = n
			let winner = indent
		endif
	endfor

	if tabbed > spaced*4 " Over 80% tabs
		" echo "Detected indent: tab"
		setlocal noexpandtab shiftwidth=0 softtabstop=0
	elseif spaced > tabbed*4 && max*5 > total*3
		" Detected over 80% spaces and the most common indentation level makes
		" up over 60% of all indentations in the file.
		" echo "Detected indent: " . winner . " spaces"
		setlocal expandtab
		let &shiftwidth=winner
		let &softtabstop=winner
	endif
endfunction

let g:project_vimrc = '.project.vim'
let g:RootMarks = ['.git', '.root', '.noterepo', '.coderepo', '.marksman.toml', g:project_vimrc, 'tags', 'GTAGS']

let s:has_vimrcd = isdirectory(expand('~/.vim/vimrc.d'))
if !s:has_vimrcd || !file_readable('.editorconfig')
	autocmd FileType * call s:DetectIndent()
	colorscheme desert
	hi ColorColumn ctermbg=black guibg=black
endif

let g:no_plug = 0
if exists("g:vscode")
	let g:loaded_netrw = 1
	let g:loaded_netrwPlugin = 1
	if s:has_vimrcd
		source ~/.vim/vimrc.d/plugin.vim
	endif
	finish
endif

" 显示空白字符
" https://codepoints.net/U+23B5
" set listchars=eol:⏎,tab:¦\ ,trail:␠,nbsp:⎵,extends:»,precedes:«
set listchars=tab:¦\ ,trail:␠,nbsp:⎵,extends:»,precedes:«
set list

set guifont=Monospace\ Regular\ 20
set mouse=a
if ! has('nvim') && has('unix') && (exists('$WSLENV') || exists('$TMUX'))
	set ttymouse=xterm2 " Windows termimal 可以用鼠标改变窗口大小
endif

if has("nvim-0.5.0") || has("patch-8.1.1564")
	set signcolumn=number " 合并git状态与行号
elseif v:version >= 801
	set signcolumn=yes " 同时显示git状态和行号
endif

if v:version >= 801
	" https://unix.stackexchange.com/questions/149209/refresh-changed-content-of-file-opened-in-vim/383044#383044
	" Set to auto read when a file is changed from the outside
	set autoread
	" Triger `autoread` when files changes on disk
	" https://unix.stackexchange.com/questions/149209/refresh-changed-content-of-file-opened-in-vim/383044#383044
	" https://vi.stackexchange.com/questions/13692/prevent-focusgained-autocmd-running-in-command-line-editing-mode
	autocmd FocusGained,BufEnter,CursorHold,CursorHoldI *
				\ if mode() !~ '\v(c|r.?|!|t)' && getcmdwintype() == '' | checktime | endif

	" Notification after file change
	" https://vi.stackexchange.com/questions/13091/autocmd-event-for-autoread
	autocmd FileChangedShellPost *
				\ echohl WarningMsg | echo "File changed on disk. Buffer reloaded." | echohl Noneau FocusGained,BufEnter * checktime
endif

"""""""""""""""""""""""""""""""

if has("patch-8.1.0360")
	set diffopt=vertical,filler,context:3,indent-heuristic,algorithm:patience,internal
endif

""""""""""""""""""""""""""""""""""""""""""""""""""""" termdebug
set t_Co=256
set t_ut=
hi debugPC term=reverse ctermbg=4 guibg=darkblue

if has('nvim') || v:version >= 801
	autocmd Filetype c,cpp,rust packadd termdebug
	let g:termdebug_wide = 1
	" 设置一个较大的宽度，防止termdebug gdb窗口折行
	autocmd Filetype termdebug setlocal termwinsize=0*10000
	let g:termdebug_config = {}
	let g:termdebug_config['command'] = "gdb"
endif

""""""""""""""""""""""""""""""""""""""""""""""""""" Netrw Plugin
"  open explorer :Ex :Sex :Vex
" close explorer :Rex
"
" do not load netrw
" let g:loaded_netrw = 1
" let g:loaded_netrwPlugin = 1
let g:netrw_browse_split = 0 " open the file using netrw buffer
let g:netrw_liststyle = 3 " tree style listing
let g:netrw_preview = 0 " preview window horizontally
if exists('$WSLENV')
	let g:netrw_browsex_viewer="start"
endif
let g:netrw_hide = 1 " show not-hidden files
let g:netrw_keepdir=0
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" Commenting blocks of code.
augroup commenting_blocks_of_code
	autocmd!
	autocmd FileType c,cpp,java,scala,rust,go                 let b:comment_leader = '// '
	autocmd FileType sh,ruby,python,conf,fstab,gitconfig,config,yaml  let b:comment_leader = '# '
	autocmd FileType tex                                   let b:comment_leader = '% '
	autocmd FileType mail,markdown                         let b:comment_leader = '> '
	autocmd FileType vim                                   let b:comment_leader = '" '
	autocmd FileType lua                                   let b:comment_leader = '-- '
augroup end

" https://stackoverflow.com/questions/1676632/whats-a-quick-way-to-comment-uncomment-lines-in-vim
" A sed (s/what/towhat/where) command changing ^ (start of line) to the correctly set comment character based on the type of file you have opened 
" As for the silent thingies they just suppress output from commands. 
" :nohlsearch stops it from highlighting the sed search
noremap <silent> <leader>mc :<C-B>silent <C-E>s/^/<C-R>=escape(b:comment_leader,'\/')<CR>/<CR>:nohlsearch<CR>
noremap <silent> <leader>mu :<C-B>silent <C-E>s/^\V<C-R>=escape(b:comment_leader,'\/')<CR>//e<CR>:nohlsearch<CR>

augroup jump_to_symbol
	autocmd!
	" See: https://stackoverflow.com/questions/12128678/vim-go-to-beginning-end-of-next-method
	" #gpt4-answer
	" jump to the previous function
	" 向后（b表示backward）搜索一个匹配特定模式的地方，这个模式是一个函数的开始位置。
	autocmd FileType c,cpp nnoremap <silent> [f :call search('\(\(if\\|for\\|while\\|switch\\|catch\)\_s*\)\@64<!(\_[^)]*)\_[^;{}()]*\zs{', "bw")<CR>
	" jump to the next function
	" 向前（w表示forward）搜索一个匹配特定模式的地方，这个模式是一个函数的开始位置。
	autocmd FileType c,cpp nnoremap <silent> ]f :call search('\(\(if\\|for\\|while\\|switch\\|catch\)\_s*\)\@64<!(\_[^)]*)\_[^;{}()]*\zs{', "w")<CR>
	" 搜索的模式是一个正则表达式，用来匹配不是在if, for, while, switch, 和catch后面的左花括号{，因为在C++中函数的定义是以左花括号开始的。
	" 需要注意的是，这个搜索模式可能并不完全精确，因为函数的定义还可能包含许多其他的复杂性，比如模板函数，函数指针，宏定义等等。对于一些简单的代码文件，这个方法通常可以工作得很好。
	" 这些配置会更好地在代码中快速导航，但如果你需要更精确地识别函数，你可能需要考虑使用一些更高级的插件，比如ctags,cscope等等。

	" Go 语言的函数定义是以 func 关键字开始的，所以我们可以使用这个关键字来搜索函数的开始位置。
	" 在这里，我们用 \< 和 \> 来指定词的边界，这样我们就可以准确地匹配func，而不是 func 作为其他词的一部分。bW 和 wW是搜索命令的标志，b 表示向后搜索，w 表示向前搜索，W 表示只匹配整个单词。
	autocmd FileType go nnoremap <silent> <buffer> [f :call search('\<func\>', "bW")<CR>
	autocmd FileType go nnoremap <silent> <buffer> ]f :call search('\<func\>', "wW")<CR>
	" 以上代码仅会简单地跳转到包含 func 关键字的行，不过如果你需要更精确或更高级的功能，你可能需要考虑使用一些专门为
	" Go 语言设计的 Vim 插件，例如 vim-go。这个插件为 Go语言提供了许多功能，包括代码导航、自动完成、代码格式化等等。
	autocmd FileType python nnoremap <silent> <buffer> [f :call search('\<def\>', "bW")<CR>
	autocmd FileType python nnoremap <silent> <buffer> ]f :call search('\<def\>', "wW")<CR>
	autocmd FileType rust nnoremap <silent> <buffer> [f :call search('\<fn\>', "bW")<CR>
	autocmd FileType rust nnoremap <silent> <buffer> ]f :call search('\<fn\>', "wW")<CR>
	autocmd FileType lua nnoremap <silent> <buffer> [f :call search('\<function\>', "bW")<CR>
	autocmd FileType lua nnoremap <silent> <buffer> ]f :call search('\<function\>', "wW")<CR>

	autocmd FileType c,cpp nnoremap <silent> <buffer> [t :call search('\<class\>\|\<struct\>\|\<enum\>\|\<typedef\>', "bW")<CR>
	autocmd FileType c,cpp nnoremap <silent> <buffer> ]t :call search('\<class\>\|\<struct\>\|\<enum\>\|\<typedef\>', "wW")<CR>
	autocmd FileType go nnoremap <silent> <buffer> [t :call search('\<type\>', "bW")<CR>
	autocmd FileType go nnoremap <silent> <buffer> ]t :call search('\<type\>', "wW")<CR>
	autocmd FileType rust nnoremap <silent> <buffer> [t :call search('\<struct\>\|\<enum\>\|\<type\>', "bW")<CR>
	autocmd FileType rust nnoremap <silent> <buffer> ]t :call search('\<struct\>\|\<enum\>\|\<type\>', "wW")<CR>
	autocmd FileType python nnoremap <silent> <buffer> [t :call search('\<class\>', "bW")<CR>
	autocmd FileType python nnoremap <silent> <buffer> ]t :call search('\<class\>', "wW")<CR>
augroup END

function GetVisualSelection()
	" https://stackoverflow.com/questions/1533565/how-to-get-visually-selected-text-in-vimscript
	" Why is this not a built-in Vim script function?!
	let [line_start, column_start] = getpos("'<")[1:2]
	let [line_end, column_end] = getpos("'>")[1:2]
	let lines = getline(line_start, line_end)
	if len(lines) == 0
		return ''
	endif
	let lines[-1] = lines[-1][: column_end - (&selection == 'inclusive' ? 1 : 2)]
	let lines[0] = lines[0][column_start - 1:]
	return join(lines, "\n")
endfunction

function ShowQuickfixListIfNotEmpty()
	let length = len(getqflist())
	if length > 1
		copen
	elseif length == 1
		copen
		ccl
	elseif length == 0
		echo 'empty quickfix list'
	endif
endfunction

function VimGrepFindWord(word)
	if &filetype == 'c' || &filetype == 'cpp'
		let extention = '**/*.c **/*.cpp **/*.cc **/*.h'
	else
		let extention = '**/*.' . expand('%:e')
	endif
	" <pattern>: 匹配整个单词
	silent exe 'silent! vimgrep' '/\<'.a:word.'\>/' extention
	call ShowQuickfixListIfNotEmpty()
endfunction

nnoremap <silent> <leader>fw :call VimGrepFindWord(expand("<cword>"))<CR>
vnoremap <silent> <leader>fw :call VimGrepFindWord(GetVisualSelection())<CR>
command! -nargs=1 Vimfw call VimGrepFindWord(<q-args>)

function VimGrepFindType(word)
	call setqflist([])
	" <pattern>: 匹配整个单词
	if &filetype == 'c'	
		silent exe 'silent! vimgrepadd' '/\<struct '.a:word.'\>/' '**/*.c' '**/*.h'
		silent exe 'silent! vimgrepadd' '/\<union '.a:word.'\>/' '**/*.c' '**/*.h'
	elseif &filetype == 'cpp'
		silent! exe 'silent! vimgrepadd' '/\<struct '.a:word.'\>/' '**/*.cpp' '**/*.cc' '**/*.h'
		silent! exe 'silent! vimgrepadd' '/\<union '.a:word.'\>/' '**/*.cpp' '**/*.cc' '**/*.h'
		silent! exe 'silent! vimgrepadd' '/\<class '.a:word.'\>/' '**/*.cpp' '**/*.cc' '**/*.h'
	elseif &filetype == 'python'
		silent exe 'silent! vimgrepadd' '/\<class '.a:word.'\>/' '**/*.py'
	elseif &filetype == 'go'
		silent exe 'silent! vimgrepadd' '/\<type '.a:word.'\>/' '**/*.go'
	else
		echo 'unsupport filetype: '.&filetype
		return
	endif
	call ShowQuickfixListIfNotEmpty()
endfunction

nnoremap <silent> <leader>fy :call VimGrepFindType(expand("<cword>"))<CR>
vnoremap <silent> <leader>fy :call VimGrepFindType(GetVisualSelection())<CR>
command! -nargs=1 Vimfy call VimGrepFindType(<q-args>)

function VimGrepFindDefinition(word)
	call setqflist([])
	if &filetype == 'cpp' || &filetype == 'c'
		silent! exe 'silent! vimgrepadd' '/\<'.a:word.'(\(\w\|,\|\s\|\r\|\n\)\{-})\(\s\|\r\|\n\)\{-}{/' '**/*.cpp' '**/*.cc' '**/*.h'
	elseif &filetype == 'python'
		silent! exe 'silent! vimgrepadd' '/\<def '.a:word.'(/' '**/*.py'
	elseif &filetype == 'go'
		silent! exe 'silent! vimgrepadd' '/\<func '.a:word.'(/' '**/*.go'
	else
		echo 'unsupport filetype: '.&filetype
		return
	endif
	call ShowQuickfixListIfNotEmpty()
endfunction

nnoremap <silent> <leader>fd :call VimGrepFindDefinition(expand("<cword>"))<CR>
vnoremap <silent> <leader>fd :call VimGrepFindDefinition(GetVisualSelection())<CR>
command! -nargs=1 Vimfd call VimGrepFindDefinition(<q-args>)

" Reference: vim.fandom.com/wiki/Searching_for_files
" find files and populate the quickfix list
" :find :new :edit :open 只能找一个文件，需要配合wildmenu逐级搜索文件夹
" :new 开新的window
" :edit 在当前buffer
" :open 无法使用通配符，不能使用wildmode
" :next 可以打开多个文件
function FindFiles(filename)
	cexpr system('find . -name "*'.a:filename.'*" | xargs file | sed "s/:/:1:/"')
	set errorformat=%f:%l:%m
	call ShowQuickfixListIfNotEmpty()
endfunction
command! -nargs=1 FindFiles call FindFiles(<q-args>)

function Ripgrep(args)
	cexpr system('rg --vimgrep ' . a:args)
	call ShowQuickfixListIfNotEmpty()
endfunction
" fzf.vim defines :Rg
command! -nargs=1 Myrg call Ripgrep(<q-args>)

"""""""""""""""""""""""""""""""""""""" quickfix window

noremap ]q :call ToggleQuickfix()<CR>
function! ToggleQuickfix()
  if empty(filter(range(1, winnr('$')), 'getwinvar(v:val, "&buftype") == "quickfix"'))
    copen
  else
    cclose
  endif
endfunction

nnoremap <silent> <leader>cn :cn<CR>
nnoremap <silent> <leader>cp :cp<CR>

vnoremap <silent> <leader>t :term ++open ++rows=9<CR>
nnoremap <silent> <leader>t :term ++rows=9<CR>
if exists(':tnoremap')
	tnoremap <silent> <leader>t <C-W>:hide<CR>
endif

function CExprSystem(args)
	cexpr system(a:args)
	call ShowQuickfixListIfNotEmpty()
endfunction
" [[palette]]执行系统命令并输出到quickfix list			:CExprsys
command! -nargs=1 CExprsys call CExprSystem(<q-args>)

"""""""""""""""""""""""""""""""""""""""""""""""""""""""

" Example:
" :e+22 ~/.vimrc
command! -nargs=0 VimExeLine exe getline(".")

set foldmethod=marker
set foldmarker={,}

function! CppFoldExpr(lnum)
	let line = getline(a:lnum)
	if !exists('b:cpp_fold_level')
		let b:cpp_fold_level = 0
		let b:last_primitive = ''
	endif

	let open_braces = len(split(line, '{', 1)) - 1
	let close_braces = len(split(line, '}', 1)) - 1
	
	if b:last_primitive == 'if'
		let b:cpp_fold_level += 1
	elseif b:last_primitive == 'end'
		let b:cpp_fold_level -= 1
	endif
	let b:last_primitive = ''
	
	if line =~ '^\s*#\s*\(ifdef\|ifndef\|if\)' || open_braces > close_braces
		let b:cpp_fold_level += 1
		let b:last_primitive = 'if'
		return b:cpp_fold_level
	elseif line =~ '^\s*#\s*\(else\|elif\)' || (open_braces == close_braces && open_braces > 0)
		return b:cpp_fold_level - 1
	elseif line =~ '^\s*#\s*endif' || close_braces > open_braces
		let b:last_primitive = 'end'
		let b:cpp_fold_level -= 1
		return b:cpp_fold_level
	endif

	return b:cpp_fold_level
endfunction

autocmd FileType c,cpp setlocal foldmethod=expr foldexpr=CppFoldExpr(v:lnum)
autocmd FileType python,vim,lua setlocal foldmethod=indent

" 默认打开所有折叠，将foldlevelstart设置为较大的值
"" set foldlevel=-1 " 默认关闭所有折叠
set foldlevelstart=99
" https://www.zhihu.com/question/30782510/answer/70078216
nnoremap zpr :setlocal foldexpr=(getline(v:lnum)=~@/)?0:(getline(v:lnum-1)=~@/)\\|\\|(getline(v:lnum+1)=~@/)?1:2 foldmethod=expr foldlevel=0 foldcolumn=2<CR>:set foldmethod=syntax<CR><CR>
" 打开所有折叠: zR

set makeprg=make

function EchoGitBlame()
	let line_number = line(".")
	echo system('git blame -n -L ' . line_number . ',' . line_number . ' -- ' . expand('%'))
endfunction

" command -nargs=0 GitBlame !git blame -L line(".") + 1, line(".") + 1 -- %
" [[palette]]git-blame						:GitBlame
command -range -nargs=0 GitBlame :!git blame -n -L <line1>,<line2> -- %

if &insertmode == 0
	" save
	inoremap <c-S> <esc>:w<CR>i
end

" neovim 会报错
if isdirectory(expand('~/.vim/doc')) && !has('nvim')
	set helplang=cn
	helptags ~/.vim/doc
endif

" Load plugins
if s:has_vimrcd
	source ~/.vim/vimrc.d/plugin.vim
endif
if !s:has_vimrcd || g:no_plug == 1
	colorscheme default
endif

if !exists("g:plugs") || !has_key(g:plugs, 'coc.nvim')
	" https://zhuanlan.zhihu.com/p/106309525
	if has("autocmd") && exists("+omnifunc")
		autocmd Filetype * if &omnifunc == "" | setlocal omnifunc=syntaxcomplete#Complete | endif
	endif
endif

""""""""""""""""""""" StatusLine """"""""""""""""""

let s:cached_branch = ''
let s:last_update_time = 0

function GetGitBranchCB(channel, message)
	let s:cached_branch = a:message
	let s:last_update_time = localtime()
endfunction

function GetGitBranch()
	let l:current_time = localtime()
	if l:current_time - s:last_update_time < 5
		return s:cached_branch
	endif

	let l:cmd = ['git', 'rev-parse', '--abbrev-ref', 'HEAD']
	call job_start(l:cmd, {'out_cb': 'GetGitBranchCB'})
	return s:cached_branch
endfunction

function LeftStatusLine()
	let l:result = ''
	
	let l:gitbranch = GetGitBranch()
	let l:result .= l:gitbranch == '' ? '' : (' ' . l:gitbranch . ' ')

	if g:vimrc_use_coc && exists('g:plugs') && g:no_plug == 0
		let l:coc_current_function = get(b:, 'coc_current_function', '')
		let l:result .= l:coc_current_function == '' ? '' : (' ' . l:coc_current_function . ' ')
		let l:cocstat = coc#status()
		let l:result .= l:cocstat == '' ? '' : (l:cocstat . ' ')
	endif

	return l:result
endfunction

if g:no_plug == 0
	function RightStatusLine()
		let l:result = ''
		if g:asyncrun_status == 'running'
			let l:result .= ' '
		elseif g:asyncrun_status == 'success'
			let l:result .= '󰄴 '
		elseif g:asyncrun_status == 'failure'
			let l:result .= ' '
		endif
		return l:result
	endfunction
endif

" 设置状态行-----------------------------------
" 设置状态行显示常用信息
" %F 完整文件路径名
" %m 当前缓冲被修改标记
" %m 当前缓冲只读标记
" %h 帮助缓冲标记
" %w 预览缓冲标记
" %Y 文件类型
" %b ASCII值
" %B 十六进制值
" %l 行数
" %v 列数
" %p 当前行数占总行数的的百分比
" %L 总行数
" %{...} 评估表达式的值，并用值代替
" %{"[fenc=".(&fenc==""?&enc:&fenc).((exists("+bomb") && &bomb)?"+":"")."]"} 显示文件编码
" %{&ff} 显示文件类型
" 链接：https://zhuanlan.zhihu.com/p/532430825
set laststatus=2
if !has('nvim') || g:nvim_compatibility_with_vim == 1
	set statusline=%1*%F%m%r%h%w\ \|\ 
	if exists("g:plugs") && v:version >= 810
		set statusline+=%{LeftStatusLine()}
	endif
	" 左对齐和右对齐的分割点
	set statusline+=%=
	if exists("g:plugs") && v:version >= 810 && g:no_plug == 0
		set statusline+=%{RightStatusLine()}
	endif
	set statusline+=%2*\ %Y\ %3*%{\"\".(\"\"?&enc:&fenc).((exists(\"+bomb\")\ &&\ &bomb)?\"+\":\"\").\"\"}\ %4*[%l,%v]\ %5*%p%%\ \|\ %6*%LL\ 
endif

" file is large from 10mb
let g:LargeFile = 1024 * 1024 * 10
augroup LargeFile
  au!
  autocmd BufReadPre * let f=getfsize(expand("<afile>")) | if f > g:LargeFile || f == -2 | call LargeFile() | endif
augroup END

function! LargeFile()
	" no syntax highlighting etc
	set eventignore+=FileType
	" save memory when other file is viewed
	setlocal bufhidden=unload
	" is read-only (write with :w new_filename)
	setlocal buftype=nowrite
	" no undo possible
	setlocal undolevels=-1
	" display message
	autocmd VimEnter *  echo "The file is larger than " . (g:LargeFile / 1024 / 1024) . " MB, so some options are changed (see vimrc for details)."
endfunction

" https://www.zhihu.com/question/26248191/answer/2680677733
function! GoToFile(file,lineNum)
  let bufName = bufname(a:file)
  if bufName == ""
    execute 'edit +'.a:lineNum a:file
  else
    let bufNum = bufnr(bufName)
    execut 'b '.bufNum
    call feedkeys(a:lineNum."G","n")
  endif

  if foldclosed('.') != -1
   call feedkeys("zo","n")
  end

  call feedkeys("zz","n")
endfunction

""""""""""""""""""" Marks """"""""""""""""""""""
sign define marka text='a texthl=Todo
sign define markb text='b texthl=Todo
sign define markc text='c texthl=Todo
sign define markd text='d texthl=Todo
sign define marke text='e texthl=Todo
sign define markf text='f texthl=Todo
sign define markg text='g texthl=Todo
sign define markh text='h texthl=Todo
sign define marki text='i texthl=Todo
sign define markj text='j texthl=Todo
sign define markk text='k texthl=Todo
sign define markl text='l texthl=Todo
sign define markm text='m texthl=Todo
sign define markn text='n texthl=Todo
sign define marko text='o texthl=Todo
sign define markp text='p texthl=Todo
sign define markq text='q texthl=Todo
sign define markr text='r texthl=Todo
sign define marks text='s texthl=Todo
sign define markt text='t texthl=Todo
sign define marku text='u texthl=Todo
sign define markv text='v texthl=Todo
sign define markw text='w texthl=Todo
sign define markx text='x texthl=Todo
sign define marky text='y texthl=Todo
sign define markz text='z texthl=Todo

" A-Z mark目前不支持在初始化阶段添加sign
sign define markA text='A texthl=Todo
sign define markB text='B texthl=Todo
sign define markC text='C texthl=Todo
sign define markD text='D texthl=Todo
sign define markE text='E texthl=Todo
sign define markF text='F texthl=Todo
sign define markG text='G texthl=Todo
sign define markH text='H texthl=Todo
sign define markI text='I texthl=Todo
sign define markJ text='J texthl=Todo
sign define markK text='K texthl=Todo
sign define markL text='L texthl=Todo
sign define markM text='M texthl=Todo
sign define markN text='N texthl=Todo
sign define markO text='O texthl=Todo
sign define markP text='P texthl=Todo
sign define markQ text='Q texthl=Todo
sign define markR text='R texthl=Todo
sign define markS text='S texthl=Todo
sign define markT text='T texthl=Todo
sign define markU text='U texthl=Todo
sign define markV text='V texthl=Todo
sign define markW text='W texthl=Todo
sign define markX text='X texthl=Todo
sign define markY text='Y texthl=Todo
sign define markZ text='Z texthl=Todo

function SignMark(mark)
  call sign_unplace(a:mark, {'buffer': bufnr()})
  call sign_place(0, a:mark, a:mark, bufnr(), {'lnum': line('.'), 'priority': 20})
endfunction

" 为小写字母 a 到 z 创建映射
for mark in range(char2nr('a'), char2nr('z'))
  let sign_name = 'mark' . nr2char(mark)
  execute 'nnoremap m' . nr2char(mark) . ' m' . nr2char(mark) . ':call SignMark("' . sign_name . '")<CR>'
endfor

" 为大写字母 A 到 Z 创建映射
for mark in range(char2nr('A'), char2nr('Z'))
  let sign_name = 'mark' . nr2char(mark)
  execute 'nnoremap m' . nr2char(mark) . ' m' . nr2char(mark) . ':call SignMark("' . sign_name . '")<CR>'
endfor
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"
""""""""""""""""""" tag system """"""""""""""""""""""""""
" 当前使用.globalrc配置文件
" let $GTAGSCONF = '/root/gtags.conf'

" 不使用 ludovicchabant/vim-gutentags 插件的原因:
" 该插件会设置$GTAGSROOT 和 $GTAGSDBPATH 环境变量，导致gtags不能按预期工作

" 递归向上层寻找tags文件
" set tags=tags;/

if has("cscope")
	" use both cscope and ctag for 'ctrl-]', ':ta', and 'vim -t'
	set cscopetag
	" 使用quickfix窗口显示搜索结果
	if v:version >= 800
		set cscopequickfix=s-,g-,c-,t-,e-,f-,i-,d-,a-
	else
		set cscopequickfix=s-,g-,c-,t-,e-,f-,i-,d-
	endif

	" show msg when any other cscope db added
	set cscopeverbose
	" 先搜索cscope数据库，如果没有再搜索tags
	set csto=0
	" This tests to see if vim was configured with the '--enable-cscope' option
	" when it was compiled.  If it wasn't, time to recompile vim... 
	
	""""""""""""" My cscope/vim key mappings
	"
	" The following maps all invoke one of the following cscope search types:
	"
	"   's'   symbol: find all references to the token under cursor
	"   'g'   global: find global definition(s) of the token under cursor
	"   'c'   calls:  find all calls to the function name under cursor
	"   't'   text:   find all instances of the text under cursor
	"   'e'   egrep:  egrep search for the word under cursor
	"   'f'   file:   open the filename under cursor
	"   'i'   includes: find files that include the filename under cursor
	"   'd'   called: find functions that function under cursor calls
	"   'a'   assigned: find places where this symbol is assigned a value

	" <C-R>= ... <CR> 用于计算表达式（如2+2， expand("<cword>")等），并将结果插入到命令行中
	nnoremap <leader>cs :cs find s <C-R>=expand("<cword>")<CR><CR>
	nnoremap <leader>cg :cs find g <C-R>=expand("<cword>")<CR><CR>
	nnoremap <leader>cc :cs find c <C-R>=expand("<cword>")<CR><CR>
	nnoremap <leader>ct :cs find t <C-R>=expand("<cword>")<CR><CR>
	nnoremap <leader>ce :cs find e <C-R>=expand("<cword>")<CR><CR>
	nnoremap <leader>cf :cs find f <C-R>=expand("<cword>")<CR><CR>
	nnoremap <leader>ci :cs find i <C-R>=expand("<cword>")<CR><CR>
	nnoremap <leader>cd :cs find d <C-R>=expand("<cword>")<CR><CR>
	nnoremap <leader>ca :cs find a <C-R>=expand("<cword>")<CR><CR>

	" 分裂窗口显示搜索结果
	" nmap <C-@>s :scs find s <C-R>=expand("<cword>")<CR><CR>
	" nmap <C-@><C-@>s :vert scs find s <C-R>=expand("<cword>")<CR><CR>

	if g:tag_system == 'cscope'
		" Reference: https://cscope.sourceforge.net/cscope_maps.vim
		""""""""""""" Standard cscope/vim boilerplate

		" reset cscope:
		" :cs reset

		" add any cscope database in current directory
		if filereadable("cscope.out")
			cs add cscope.out
		" else add the database pointed to by environment variable
		elseif $CSCOPE_DB != ""
			cs add $CSCOPE_DB
		endif

	elseif g:tag_system == 'gtags-cscope'
    set csprg=gtags-cscope
		if s:has_vimrcd && exists('g:plugs') && g:no_plug == 0
			function s:gtags_cscope_add()
				let l:project_root = asyncrun#current_root()
				if l:project_root != $HOME && l:project_root != ''
					let l:gtags_db = l:project_root . '/GTAGS'
					if filereadable(l:gtags_db) && cscope_connection(2, l:gtags_db) == 0
						execute 'cs add ' . l:gtags_db
					endif
				endif
			endfunction
			
			augroup GlobalCscope
				autocmd!
				" 自动加载gtags db
				autocmd VimEnter * call s:gtags_cscope_add()
			augroup END
			
			" 不使用global官方gtags-cscope vimscript
			" https://www.gnu.org/software/global/globaldoc_toc.html#Gtags_002dcscope
			" source ~/.vim/vimrc.d/gtags-cscope.vim
		endif
	endif
	if s:has_vimrcd && exists('g:plugs') && g:no_plug == 0
		let g:Gtags_Auto_Update = 1
		source ~/.vim/vimrc.d/gtags_asyncrun.vim " https://www.gnu.org/software/global/globaldoc_toc.html#Vim-editor
		" nnoremap <C-]> :Gtags -d <C-R>=expand("<cword>")<CR><CR>
	endif
endif

