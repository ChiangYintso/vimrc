vim:ft=help

*vim-git-help*
*git-help*
*git*

==============================================================================
Git 开发规范
https://github.com/universal-ctags/ctags/pull/3747
https://git-scm.com/book/en/v2/Git-Branching-Branching-Workflows

|git-flow|

See also:
$DOC2/cs/system/software_engineering/version-control-and-release-model
$DOC2/cs/tools-open-source/git-github

==============================================================================
Git 修改历史提交的文件                                 *git-modify-history-file*

如果你想修改历史提交中的某个文件，你可以使用以下步骤：

1. 使用 'git log' 查看提交历史，找到你想要修改的提交的哈希值。

2. 执行 'git rebase -i <commit_hash>^' 进入交互式 rebase 模式。
   ('commit_hash' 是你在第一步找到的哈希值。'^' 符号表示父提交)

3. 在你想要修改的提交前面，将 'pick' 改为 'edit'。

4. 保存并关闭编辑器，然后使用 'git checkout -- <filename>' 来恢复你想要修改
   的文件到这次提交的状态。

5. 对文件进行你需要的修改。

6. 提交这个修改，你可以使用 'git add <filename>' 添加修改，然后用
   'git commit --amend' 修改这个提交。

7. 运行 'git rebase --continue' 完成 rebase 操作。

*git将某一个commit拆分为2个*
>
  git rebase -i abc123^ # ^指abc123前一个commit
  git reset HEAD^       # 将该commit回退一个更改，但保留更改内容
  git add ...
  git commit ...
  git rebase --continue
<

https://git-scm.com/book/en/v2/Git-Tools-Rewriting-History

*git从历史提交中永久删除文件*			git filter-branch --force --index-filter 'git rm --cached --ignore-unmatch root/.vim/doc/tags-cn' --prune-empty --tag-name-filter cat -- --all

*git-filter-repo*

https://github.com/newren/git-filter-repo#how-do-i-install-it
>
  apt install git-filter-repo
<

删除历史中的所有.onnx文件，--invert-paths表示除了指定的文件外，保留所有其他文件
>
	git filter-repo --path-glob '*.onnx' --invert-paths
<
该操作可能导致remote消失，需要重新git remote add

https://docs.github.com/zh/authentication/keeping-your-account-and-data-secure/removing-sensitive-data-from-a-repository

-------------------------------------------------------------------------------
*git-fetch*

git只fetch某个远程仓库的某一个分支 >
  git fetch origin master
<

-------------------------------------------------------------------------------
git commit --amend                                      *git-commit-amend*

'git commit --amend' 是一个 Git 命令，用于修改最近一次提交。这个命令会将暂存区中
的文件添加到最近一次的提交中，并允许你修改提交信息。

如果你提交后忘记了包含一些修改的文件，你可以简单地将它们添加到暂存区，然后运行
'git commit --amend'。如果你的最新提交信息有误（例如拼写错误或描述不清），你可以
使用 'git commit --amend' 来更改它。

如果你不小心使用 'git commit --amend' 命令，并想撤销对最近一次提交的修改，你可以
使用 'git reset --hard ORIG_HEAD' 命令。这会撤销 'git commit --amend' 对最近一次
提交的所有修改，并将这些修改留在工作区。

amend同时修改日期 >
  git commit --amend --date=now
<

-------------------------------------------------------------------------------
git reset                                             *git-reset*

'git reset --soft <commit_hash>' 用于将 HEAD 指针移动到指定的提交，
并将该提交后的所有提交放回暂存区。'<commit_hash>' 是你想要回滚到的提交的哈希值。

'git reset <commit_hash>' : 将所有提交放回unstaged area.

如果你不小心使用了 'git reset HEAD~3' 并希望恢复，你可以使用 'git reflog' 查找到你
想要恢复的提交的哈希值，然后使用 'git reset --hard <commit_hash>' 来恢复。

*git强行将当前分支和main分支同步*  *git-reset-hard*
>
	git reset --hard main
<

-------------------------------------------------------------------------------
git checkout                                        *git-checkout*

'git checkout <commit_hash> -- <filename>' 是一个 Git 命令，用于将特定文件回滚到
某次提交的状态。'<commit_hash>' 是你想要回滚到的提交的哈希值，'<filename>' 是你想要
回滚的文件。

这个命令可以用来回滚部分文件，例如你可以使用 'git checkout HEAD~1 -- README.md' 来
将 'README.md' 文件回滚到上一次提交的状态。

如果你想要暂时跳转到某一次历史提交，你可以使用 'git checkout <commit_hash>'。然后，
当你想要回到原来的状态时，你可以使用 'git checkout <branch_name>'，'<branch_name>'
是你之前所在的分支的名称。

*撤销某一个文件的修改*			git checkout -- 文件名
git checkout 可以checkout部分文件到某一次提交/分支。可以用于回滚部分文件。

*git-checkout历史文件*			git checkout v0.2.2 -- markdown.vim

-------------------------------------------------------------------------------
git rebase --edit-timestamp            *git-rebase*

'git rebase --edit-timestamp' 是一个选项，可以在 'git rebase' 命令中使用。这个选项
会允许你在 rebase 过程中编辑每次提交的时间戳。

你可以使用 'git rebase -i --root' 来进入交互式 rebase 模式，并编辑每次提交的时间戳。

在你想要修改的提交前面，将 'pick' 改为 'edit'，然后保存并退出编辑器。然后，执行
'git commit --amend --date="<date>"' 来修改提交日期，'<date>' 是你想要设置的日期和
时间。最后，执行 'git rebase --continue' 来完成 rebase 操作。


*git-initial-commit*
`git rebase -i --root` 修改第一次commit

-------------------------------------------------------------------------------

*git提交把作者改成自己*				git commit --amend --reset-author --no-edit
*git回退版本*					git reset --soft 需要回退的commit hash
*git先暂存自己的修改，再pull别人的提交*		1) git stash 	2) git pull 	3) git pop
*git复制某一分支*				git remote set-url
*git合并commit* 				方法1)	git reset	方法2)	 git rebase -i HEAD~2

-------------------------------------------------------------------------------

*git-diff/merge*

将当前文件和它倒数第3次提交历史版本diff |:Gdiffsplit|  >
  :Gdiffsplit HEAD~3:%
<

*git-difftool*					git difftool HEAD mydoc.txt or git difftool -- mydoc.txt HEAD

|vimdiff|
vimdf 脚本

*git-mergetool*

git列举所有unmerged文件			git diff --name-only --diff-filter=U --relative
git撤销某个提交的merged文件		git restore -m foo.txt
tutorial: https://gist.github.com/karenyyng/f19ff75c60f18b4b8149
插件:     https://github.com/samoshkin/vim-mergetool

批量merge多个文件的流程 ~

通用vim命令 `:Git mergetool` , 在quickfix list加载所有unmerged file
可以用:SaveList 和 :LoadList 保存/加载quickfix list(在quickfix buffer下命令生效)

方案0: 直接修改unmerged文件 ~

例子来源于上面的tutorial
>
  root@DESKTOP-TI1H94P:~/galaxyZoo# git merge astrophy_objects
  Auto-merging astrophy_obj.txt
  CONFLICT (content): Merge conflict in astrophy_obj.txt
  Auto-merging foo.txt
  CONFLICT (add/add): Merge conflict in foo.txt
  Automatic merge failed; fix conflicts and then commit the result.
  root@DESKTOP-TI1H94P:~/galaxyZoo# git status
  On branch master
  You have unmerged paths.
    (fix conflicts and run "git commit")
    (use "git merge --abort" to abort the merge)

  Unmerged paths:
    (use "git add <file>..." to mark resolution)
	  both modified:   astrophy_obj.txt
	  both added:      foo.txt

  no changes added to commit (use "git add" and/or "git commit -a")
  root@DESKTOP-TI1H94P:~/galaxyZoo# cat foo.txt
  <<<<<<< HEAD
  abc
  ||||||| dbbf6d7
  =======
  def
  >>>>>>> astrophy_objects
<

方案1: 直接git mergetool开启merge ~

方案2: 基于vim-mergetool~

需要在.gitconfig中添加 >
  [merge]
    conflictStyle = diff3
  [merge]
    # tool = vimdiff
    tool = vim_mergetool
    conflictstyle = diff3
  [mergetool]
    keepBackup = false
  [mergetool "vim_mergetool"]
    cmd = vim -f -c "MergetoolStart" "$MERGED" "$BASE" "$LOCAL" "$REMOTE"
    # When trustExitCode = true, checks exit code of merge tool process.
    # When trustExitCode = false, checks if MERGED file was modified.
    trustExitCode = true
    prompt = false
<

1) 利用上面的`:Git mergetool`或其它方式，打开需要merge的文件后， >
  :MergetoolStart/:MergetoolToggle 开始merge
  :MergetoolStop/:MergetoolToggle  结束merge(保存或撤销)
<

用:qa!退出vim会直接判断为merge成功

其它命令
:MergetoolDiffExchangeLeft       把右边的buffer应用到左边的MERGED文件
:GitUnmergedRaw FZF打开unmerged文件，直接编辑
:GitUnmerged    FZF打开unmerged文件，然后:MergetoolStart

clean-LOCAL-BASE-REMOTE-files			git clean -i

-------------------------------------------------------------------------------
*git-clean*
*git-untracked-file*

git 删除untracked file
首先`git clean -n`，查看哪些文件会被删除
然后`git clean -f`
git 回滚untracked 修改
`git restore <file name>`

-------------------------------------------------------------------------------

*Git在单体仓库中pull部分文件*

*monorepo*

以clone [etcd/raft](https://github.com/etcd-io/etcd/tree/main/raft)为例

1) *partial-clone* >
  git clone --no-checkout https://hub.fastgit.org/etcd-io/etcd.git etcd_raft3 --depth=1 --filter=blob:none or git clone --no-checkout https://hub.fastgit.org/etcd-io/etcd.git etcd_raft3 --depth=1 --filter=tree:0
<

blob代表文件，tree代表文件夹。后者文件大小似乎略小一点。

2) *sparse-checkout* >
  cd etcd_raft3 git sparse-checkout init git sparse-checkout set '!/*/' '/raft/' git checkout main
<

当git版本>=2.32.0时，可以添加在`git sparse-checkout init`中添加`--sparse-index`选项进一步减小git文件大小，见 [https://git-scm.com/docs/git-sparse-checkout/2.32.0](https://git-scm.com/docs/git-sparse-checkout/2.32.0)

最后只有raft目录在项目文件夹中。 `git sparse-checkout list` 可以查看当前sparse-checkout的规则。

其它参考资料： [https://github.blog/tag/monorepo/](https://github.blog/tag/monorepo/) [https://github.blog/2020-01-17-bring-your-monorepo-down-to-size-with-sparse-checkout/](https://github.blog/2020-01-17-bring-your-monorepo-down-to-size-with-sparse-checkout/) [https://github.blog/2020-12-21-get-up-to-speed-with-partial-clone-and-shallow-clone/](https://github.blog/2020-12-21-get-up-to-speed-with-partial-clone-and-shallow-clone/)

-------------------------------------------------------------------------------

*藏匿当前正在修改，但尚未commit的工作区。适合临时保存、切换工作区（比如临时hotfix）*		git stash

-------------------------------------------------------------------------------

git gc, git 减小.git目录大小                        *git-gc*
>
  git gc --prune=now --aggressive
<

-------------------------------------------------------------------------------
*git-flow*
*git-branch-model*

|git|
See: $DOC2/cs/tools-open-source/git-github/git-branch-model

多人协作时，需要将本地master单分支开发模式切换为master-dev-feature... 多分支开发模式。
切换步骤如下:

在master分支中 >
  git branch dev
<

之后把master分支强行reset为远程master分支 >
  git reset --hard origin/master
<

创建新的dev分支，然后切换到dev分支中 >
  git checkout dev
<

在dev分支中，重新整理提交记录 >
  git reset <commit_hash>
<

*git-add-patch*
*git细粒度提交*
如果需要细粒度地提交，可以使用`git add -p <file>`。
git add -p会把文件的修改分成若干个更改块(hunks)，每个片段都可以选择是否提交。

如果需要临时切换到master分支，同时保留dev分支的修改，可以使用`git stash`。
*git-stash* 之后切回dev分支，使用`git stash pop`恢复修改。

可以在dev分支用`git merge master`，随时同主分支同步。

-------------------------------------------------------------------------------
*git-worktree* 多分支同时开发

好处:
1. 依赖隔离：`node_modules`被写入.gitignore中，假如多分支依赖的`node_modules`
不同，`git stash`不会改变`node_modules`

列举worktree >
	git worktree list
<

面对本地服务器+远程无法访问github的服务器同时修改提交的场景: 不可行 ~

git-worktree的.git是一个文件，里面记载了git本地仓库的绝对路径。
>
	gitdir: /root/vimrc/.git/worktrees/vimrc-kiwi
<
因此如果本地服务器和远程服务器的仓库目录不同，那么git worktree就会失效。


在gpudb-project-ictdb中，
git worktree add -b kiwi-dev ../gpudb-project-ictdb-kiwi-dev
之后本地都在gpudb-project-ictdb文件夹下开发，远程在gpudb-project-ictdb-kiwi-dev
文件夹下开发，rsync仅在gpudb-project-ictdb-kiwi-dev下拉取/推送文件

-------------------------------------------------------------------------------
*git把ssh远程服务器作为remote-repository*

NOTE: v0.16.0 后，不再使用 ~/vimrc/tools/rsync-vimrc.sh 同步git仓库。可以直接
用git同步。

*git-bare-repo*

远程服务器创建裸仓库(推荐做法) ~
>
	git init --bare /home/jiangyinzuo/vimrc.git
<

裸仓库没有工作目录，它们主要用于存储 Git 数据（如提交历史、分支、标签等），而不用于直接编辑文件。
如果需要检出远程服务器，在`/home/jiangyinzuo/vimrc.git`目录下，创建worktree
>
	git worktree add ../vimrc machine/kiwi
<

远程服务器创建非裸仓库，直接在非裸仓库checkout machine/kiwi branch(不推荐) ~
>
	git init /home/jiangyinzuo/vimrc
<

此时，本地服务器不能推送远程服务器当前检出的分支:
>
	remote: error: refusing to update checked out branch: refs/heads/machine/kiwi
	remote: error: By default, updating the current branch in a non-bare repository
	remote: is denied, because it will make the index and work tree inconsistent
	remote: with what you pushed, and will require 'git reset --hard' to match
	remote: the work tree to HEAD.
	remote:
	remote: You can set the 'receive.denyCurrentBranch' configuration variable
	remote: to 'ignore' or 'warn' in the remote repository to allow pushing into
	remote: its current branch; however, this is not recommended unless you
	remote: arranged to update its work tree to match what you pushed in some
	remote: other way.
	remote:
	remote: To squelch this message and still keep the default behaviour, set
	remote: 'receive.denyCurrentBranch' configuration variable to 'refuse'.
	To ssh://kiwi-nfd:/home/jiangyinzuo/vimrc
	 ! [remote rejected] machine/kiwi -> machine/kiwi (branch is currently checked out)
	error: failed to push some refs to 'ssh://kiwi-nfd:/home/jiangyinzuo/vimrc'
<

本地仓库添加远程仓库URL, 并推送 ~
>
	git remote add kiwi ssh://jiangyinzuo@kiwi:/home/jiangyinzuo/vimrc
	git push kiwi machine/kiwi
<
本地仓库也可以添加worktree vimrc-kiwi，然后在vimrc-kiwi worktree中
>
	git worktree add ../vimrc-kiwi machine/kiwi
	git push --set-upstream kiwi machine/kiwi
<
-------------------------------------------------------------------------------
*获得当前git仓库根目录*

git rev-parse --show-toplevel
===============================================================================

